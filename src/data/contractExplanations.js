// Contract explanations - concise explanations for each contract (under 100 words)
export const contractExplanations = {
  'hello-world': 'This is the simplest NEAR smart contract and serves as the perfect entry point for learning NEAR development. It demonstrates the fundamental structure of a NEAR smart contract: a contract struct decorated with the #[near_bindgen] macro, which is essential for all NEAR contracts as it generates the necessary boilerplate code for serialization and contract interface. The example features a single view method that returns a greeting string, showcasing how view methods work in NEAR. View methods are read-only functions that don\'t modify contract state and are completely free to call - they don\'t require transactions or gas fees. This makes them ideal for querying contract data. The example illustrates how to use the #[near_bindgen] macro to automatically generate the contract\'s public interface, allowing external calls without manual serialization. Understanding this basic pattern is crucial, as every NEAR contract follows a similar structure, building upon these core concepts to create more complex functionality.',
  
  'contract-structure': 'This contract provides a comprehensive overview of the fundamental structure that every NEAR smart contract must follow. It demonstrates the essential components: a contract struct that holds state variables (like owner_id), proper serialization using Borsh (Binary Object Representation Serializer for Hashing), and a Default implementation that enables contract initialization. The example shows how state is stored within the contract struct, which persists across all contract calls and transactions. Borsh serialization is critical because it ensures that contract state can be efficiently stored and retrieved from the blockchain\'s persistent storage. The Default trait implementation allows contracts to be initialized with default values, which is particularly useful during development and testing. This contract also demonstrates how to store and retrieve account information, a pattern that forms the foundation for access control mechanisms. Understanding this structure is essential because all NEAR contracts build upon these core principles, and mastering them will help you write more complex and secure smart contracts.',
  
  'view-methods': 'View methods are read-only functions that provide a way to query contract state without modifying it. These methods are completely free to call - they don\'t require transactions, gas fees, or wallet signatures, making them ideal for retrieving information from contracts. This example demonstrates multiple view methods with different return types: one returns a simple string, while another performs calculations and returns a numeric value. View methods can perform any computation as long as they don\'t modify state, and they can return any serializable data type including strings, numbers, structs, vectors, and maps. This makes them perfect for building user interfaces that need to display contract data, checking balances, querying ownership, or retrieving any stored information. The example shows how view methods are defined using the #[view] attribute or by simply not marking them as change methods. Understanding view methods is crucial because they represent the primary way users and applications interact with contract data, and they\'re used extensively in every NEAR application for reading contract state.',
  
  'change-methods': 'Change methods are functions that modify contract state and require a signed transaction with gas fees to execute. Unlike view methods, change methods can mutate storage, emit events, transfer tokens, and interact with other contracts through cross-contract calls. This example demonstrates how to update contract state through a change method, showing the fundamental pattern for writing data to the blockchain. When a change method is called, the caller must sign a transaction, which means they need a NEAR wallet connected and must approve the transaction. The method consumes gas (measured in teragas on NEAR), which is a small fee paid to validators for processing the transaction. Change methods are marked with the #[call] attribute or by default when a method can modify state. This example illustrates how state changes persist across transactions, meaning once you update a value, it remains changed for all future calls until modified again. Understanding change methods is essential because they represent the primary mechanism for updating contract state, handling user actions, and implementing business logic that requires persistent changes to the blockchain.',
  
  'storage-basics': 'This contract introduces the fundamental concept of storage operations on the NEAR blockchain. It demonstrates how to store and retrieve a simple string value using the contract\'s state, which is the foundation for all data persistence in NEAR smart contracts. Storage on NEAR is persistent, meaning data stored in a contract remains available across all transactions and contract calls until explicitly modified or deleted. The NEAR runtime automatically handles the serialization and deserialization of state using Borsh, so developers don\'t need to manually manage storage bytes. This example shows the basic pattern of storing a value in the contract struct and retrieving it through view methods. Understanding storage basics is crucial because every meaningful smart contract needs to maintain some form of state - whether it\'s user balances, ownership records, configuration settings, or complex data structures. The example also introduces the concept of storage costs, as storing data on-chain requires a deposit (though NEAR\'s storage staking model makes this very affordable). Mastering these basic storage operations provides the foundation for building more complex contracts that manage sophisticated state.',
  
  'state-management': 'State management is one of the most crucial aspects of smart contract development, and this example demonstrates the fundamental patterns for managing mutable state in NEAR contracts. The contract implements a simple counter that can be incremented, showing how to maintain and update state variables that persist across transactions. When you increment the counter, the new value is stored in the contract\'s state and remains available for all future calls until modified again. This example illustrates the complete lifecycle of state management: initialization (setting an initial value), reading state (through view methods), and updating state (through change methods). The counter pattern is deceptively simple but represents the core pattern used in countless real-world applications - from tracking votes and balances to managing token supplies and user data. Understanding state management is essential because every meaningful application needs to maintain some form of mutable state. The example also demonstrates how state changes are atomic - either the entire transaction succeeds and state is updated, or it fails and state remains unchanged, ensuring data consistency and reliability.',
  
  'input-validation': 'Input validation is a critical security practice that prevents invalid or malicious data from corrupting contract state or causing unexpected behavior. This example demonstrates comprehensive input validation techniques, showing how to check conditions before processing user inputs and return meaningful errors when validation fails. The contract validates various aspects of input data: checking if values are within acceptable ranges, ensuring required fields are present, verifying data formats, and preventing edge cases that could lead to bugs or exploits. Proper validation is essential for secure and reliable smart contracts because once code is deployed, it cannot be easily changed, and invalid data can lead to permanent state corruption or security vulnerabilities. This example shows how to use Rust\'s Result type to return errors gracefully, providing clear feedback about what went wrong. The validation patterns demonstrated here - checking bounds, verifying formats, and ensuring business logic constraints - are used throughout production contracts to prevent common vulnerabilities like integer overflow, underflow, and invalid state transitions. Mastering input validation is fundamental to writing secure smart contracts that can handle real-world usage safely.',
  
  'access-control': 'Access control is a fundamental security pattern that restricts who can call certain methods in a smart contract. This example demonstrates how to check the caller\'s account ID before allowing sensitive operations, ensuring that only authorized accounts can perform specific actions. The contract uses env::predecessor_account_id() to retrieve the account ID of the account that initiated the transaction, which is the standard way to identify callers in NEAR contracts. This example shows various access control patterns: checking if the caller matches a specific account, verifying ownership, and preventing unauthorized modifications. Access control is essential for securing contract functionality because without it, anyone could call any method, potentially draining funds, corrupting data, or disrupting contract operations. The example demonstrates how to use require! macros to enforce access control, which will revert the transaction with a clear error message if the check fails. Understanding access control is crucial because virtually every production contract implements some form of permission system - whether it\'s restricting administrative functions to owners, limiting token transfers to authorized accounts, or ensuring only specific roles can perform certain operations. This pattern forms the foundation for more advanced security mechanisms like role-based access control and multi-signature systems.',
  
  'error-handling': 'Error handling is essential for building robust smart contracts that can gracefully handle failures and provide meaningful feedback to users. This example demonstrates comprehensive error handling techniques using Rust\'s Result type, which allows methods to return either a successful value or an error. The contract shows how to define custom error types that provide clear, actionable information about what went wrong, rather than simply panicking or failing silently. Proper error handling improves contract reliability by allowing the contract to recover from expected failure conditions, handle edge cases gracefully, and provide users with actionable feedback about why an operation failed. This example demonstrates various error handling patterns: using Result<T, E> return types, creating custom error enums, using the ? operator for error propagation, and providing fallback values with unwrap_or(). The contract also shows how to validate inputs and return appropriate errors before attempting operations that might fail. Understanding error handling is crucial because blockchain transactions are expensive and irreversible - users need to know why their transaction failed so they can fix the issue and try again. Well-designed error messages improve user experience and make contracts easier to debug and maintain.',
  
  'events': 'Events are a powerful mechanism that allows contracts to emit structured logs that can be indexed, queried, and monitored by external systems. This example demonstrates how to define and emit events using NEAR\'s event system, which follows the NEP-297 standard for event formatting. Events are stored on-chain as part of transaction receipts and can be retrieved by indexers, making them perfect for tracking contract activity, state changes, and building analytics dashboards. The example shows how to define event structs with relevant data fields, emit events at appropriate points in contract execution, and structure events to be easily queryable. Events provide a way to track important contract activities without requiring external systems to poll contract state or parse transaction data manually. They\'re particularly useful for tracking token transfers, ownership changes, votes, and any other significant state transitions. The example demonstrates best practices for event design: including all relevant context, using clear naming conventions, and structuring data for efficient indexing. Understanding events is crucial because they enable the rich ecosystem of tools, dashboards, and analytics that make blockchain applications usable - from wallet transaction histories to DeFi analytics platforms, events power the user-facing features that make blockchain applications accessible.',
  
  'collections-vector': 'Vectors are dynamic arrays that can grow and shrink. This example demonstrates using Vector from near_sdk::collections to store lists of items. Vectors are useful for maintaining ordered collections of data. This contract shows how to add, remove, and iterate over vector elements.',
  
  'collections-map': 'Maps store key-value pairs for efficient lookups. This example demonstrates using LookupMap or UnorderedMap from near_sdk::collections. Maps are ideal for storing data indexed by unique keys, like user profiles or token balances. This contract shows basic map operations: insert, get, and remove.',
  
  'owner-pattern': 'The owner pattern restricts certain operations to a single account. This example demonstrates storing an owner account ID and checking it before allowing privileged operations. It\'s a common security pattern for contracts that need administrative functions. The owner can be set during initialization.',
  
  'role-based-access': 'Role-based access control allows multiple accounts with different permission levels. This example demonstrates managing roles (like admin, moderator, user) and checking permissions before operations. It\'s more flexible than the owner pattern and suitable for contracts with multiple privileged actors.',
  
  'pausable-contract': 'Pausable contracts can temporarily halt operations in emergencies. This example demonstrates a pause/unpause mechanism controlled by an owner. When paused, critical functions revert. This pattern is useful for responding to bugs or security issues without redeploying the contract.',
  
  'multi-signature': 'Multi-signature requires multiple approvals before executing actions. This example demonstrates collecting signatures from multiple accounts and executing only when threshold is met. It\'s essential for high-security operations where no single account should have full control.',
  
  'reentrancy-guard': 'Reentrancy guards prevent recursive calls that could exploit contract logic. This example demonstrates using a mutex-like pattern to ensure functions can\'t be re-entered while executing. This is critical for contracts handling external calls or transfers to prevent double-spending attacks.',
  
  'storage-keys': 'Storage keys organize data efficiently in contract storage. This example demonstrates using StorageKey enum to namespace different data types. Proper key management prevents storage collisions and optimizes gas costs. It shows how to structure complex state with multiple collections.',
  
  'todo-list': 'A todo list demonstrates CRUD operations with collections. This example shows creating, reading, updating, and deleting todo items stored in a vector or map. It demonstrates practical state management patterns for applications that need to maintain lists of user data.',
  
  'user-profiles': 'User profiles store account-specific data in a map. This example demonstrates mapping account IDs to profile structs containing user information. It shows how to create, update, and retrieve user data. This pattern is common in social or identity applications on NEAR.',
  
  'voting-system': 'A voting system demonstrates tallying votes and tracking participation. This example shows storing votes in a map, preventing double-voting, and calculating results. It demonstrates practical governance patterns where users can cast votes on proposals or decisions.',
  
  'testing': 'Unit testing ensures contract logic works correctly. This example demonstrates writing tests using near_sdk::test_utils and near_sdk::MockedBlockchain. Tests verify methods return expected results and handle edge cases. Comprehensive testing is essential before deploying contracts.',
  
  'panic-handling': 'Panic handling prevents contracts from failing catastrophically. This example demonstrates using expect(), unwrap_or(), and Result types to handle errors gracefully. It shows how to provide fallback values and meaningful error messages instead of panicking.',
  
  'event-patterns': 'Event patterns demonstrate emitting structured events for indexing. This example shows defining event structs, emitting events with data, and following NEAR event standards. Events enable off-chain systems to track on-chain activity and build analytics.',
  
  'initialization': 'Contract initialization sets up initial state. This example demonstrates the init function, default implementations, and migration patterns. It shows how to initialize contracts with required data and handle upgrades. Proper initialization ensures contracts start in a valid state.',
  
  'gas-optimization': 'Gas optimization reduces transaction costs. This example demonstrates techniques like batching operations, using efficient data structures, and minimizing storage reads/writes. It shows how to write cost-effective contracts that remain functional while minimizing gas consumption.',
  
  'complete-example': 'A complete example combines multiple patterns into a functional contract. This example demonstrates a full-featured application with state management, access control, events, and error handling. It serves as a reference for building production-ready NEAR smart contracts.',
  
  'simple-calls': 'Simple cross-contract calls invoke methods on other contracts. This example demonstrates using Promise to call external contracts and handle responses. It shows the basic pattern for contract-to-contract communication, which is essential for building composable DeFi applications.',
  
  'promises': 'Promises handle asynchronous cross-contract calls. This example demonstrates creating promises, chaining callbacks, and handling results. Promises allow contracts to interact with multiple contracts in parallel or sequence, enabling complex multi-contract workflows.',
  
  'nft-transfer': 'NFT transfer moves non-fungible tokens between accounts. This example demonstrates the core NFT transfer pattern: checking ownership, updating token ownership records, and emitting transfer events. It shows the fundamental operation for any NFT contract implementation.',
  
  'upgrade-pattern': 'Upgrade patterns allow contracts to be updated without losing state. This example demonstrates using migration functions to upgrade contract code while preserving data. It shows how to handle versioning and ensure backward compatibility during contract upgrades.',
  
  'simple-marketplace': 'A simple marketplace enables buying and selling items. This example demonstrates listing items, handling purchases, and managing ownership transfers. It shows basic marketplace patterns including escrow, payment processing, and item management.',
  
  'batch-operations': 'Batch operations process multiple items in a single transaction. This example demonstrates executing multiple operations atomically, reducing gas costs and improving efficiency. It shows how to handle arrays of operations and ensure all succeed or all fail together.',
  
  'nft-standard': 'NFT standard implements the NEP-171 standard for non-fungible tokens. This example demonstrates core NFT methods: transfer, approve, and view functions. It shows how to comply with NEAR NFT standards for interoperability with wallets and marketplaces.',
  
  'nft-metadata': 'NFT metadata stores token information like name, description, and media. This example demonstrates storing and retrieving metadata following NEP-177 standards. It shows how to structure token metadata for display in wallets and marketplaces.',
  
  'nft-minting': 'NFT minting creates new tokens. This example demonstrates the minting process: generating unique token IDs, assigning ownership, and storing metadata. It shows how to control who can mint and how many tokens can be created.',
  
  'nft-approval': 'NFT approval allows others to transfer tokens on your behalf. This example demonstrates the approval system: granting permissions, checking approvals, and revoking access. It enables marketplace functionality where contracts can transfer tokens.',
  
  'nft-enumeration': 'NFT enumeration lists tokens owned by accounts. This example demonstrates pagination and querying token lists. It shows how to efficiently retrieve token IDs and metadata for display in user interfaces.',
  
  'nft-royalties': 'NFT royalties ensure creators receive ongoing payments. This example demonstrates calculating and distributing royalty payments on secondary sales. It shows how to implement royalty structures that benefit original creators.',
  
  'nft-marketplace': 'An NFT marketplace enables trading non-fungible tokens. This example demonstrates listing, bidding, and purchasing NFTs. It shows marketplace patterns including escrow, fee collection, and royalty distribution.',
  
  'callbacks': 'Callbacks handle responses from cross-contract calls. This example demonstrates implementing callback functions that process results from promises. It shows how to handle success and failure cases in asynchronous contract interactions.',
  
  'cross-call-ft': 'Cross-contract FT calls interact with fungible token contracts. This example demonstrates transferring tokens between contracts, checking balances, and handling token operations. It shows how to integrate with NEAR\'s standard FT contracts.',
  
  'cross-call-nft': 'Cross-contract NFT calls interact with NFT contracts. This example demonstrates transferring NFTs between contracts, checking ownership, and handling NFT operations. It shows how to build applications that work with existing NFT contracts.',
  
  'batch-calls': 'Batch calls execute multiple cross-contract operations. This example demonstrates creating multiple promises in parallel and handling their results. It shows how to optimize gas usage by batching related contract calls.',
  
  'promise-results': 'Promise results handle outcomes from cross-contract calls. This example demonstrates checking promise status, extracting return values, and handling errors. It shows how to process results from asynchronous contract interactions.',
  
  'async-patterns': 'Async patterns manage complex asynchronous workflows. This example demonstrates chaining promises, handling dependencies, and coordinating multiple contract calls. It shows advanced patterns for building composable DeFi applications.',
  
  'callback-patterns': 'Callback patterns structure responses from cross-contract calls. This example demonstrates organizing callback logic, handling partial failures, and retrying operations. It shows how to build robust multi-contract systems.',
  
  'error-propagation': 'Error propagation handles failures across contract boundaries. This example demonstrates catching errors from promises, logging failures, and providing fallback behavior. It shows how to build resilient systems that handle partial failures gracefully.',
  
  'chain-signatures-basics': 'Chain signatures enable signing transactions for other chains. This example demonstrates the basic pattern of requesting and verifying chain signatures. It shows how NEAR contracts can authorize actions on other blockchains.',
  
  'signature-verification': 'Signature verification validates signatures from other chains. This example demonstrates checking signature validity, verifying message authenticity, and authorizing cross-chain operations. It shows how to securely verify external signatures.',
  
  'signature-requests': 'Signature requests initiate cross-chain signing operations. This example demonstrates creating signature requests, tracking their status, and handling responses. It shows how to coordinate multi-chain operations through NEAR.',
  
  'multi-chain-signing': 'Multi-chain signing handles signatures for multiple blockchains. This example demonstrates managing signatures across different chains, coordinating operations, and ensuring consistency. It shows advanced patterns for cross-chain applications.',
  
  'cross-chain-auth': 'Cross-chain authentication verifies identity across blockchains. This example demonstrates using chain signatures to prove identity on other chains. It shows how to build applications that work seamlessly across multiple blockchains.',
  
  'signature-callbacks': 'Signature callbacks handle responses from chain signature operations. This example demonstrates processing signature results, handling failures, and updating contract state. It shows how to integrate chain signatures into contract workflows.',
  
  'indexer-setup': 'Indexer setup configures systems to track on-chain events. This example demonstrates setting up indexers to monitor contract activity. It shows how to track transactions, events, and state changes for building analytics and UIs.',
  
  'queryapi-basics': 'QueryAPI basics enable querying indexed blockchain data. This example demonstrates creating queries to retrieve contract data efficiently. It shows how to access historical data and build dashboards without querying the chain directly.',
  
  'data-indexing': 'Data indexing organizes blockchain data for fast queries. This example demonstrates indexing contract events, transactions, and state changes. It shows how to structure data for efficient retrieval and analysis.',
  
  'queryapi-queries': 'QueryAPI queries retrieve indexed data using SQL-like syntax. This example demonstrates writing queries to filter, aggregate, and transform indexed data. It shows how to build complex queries for analytics and reporting.',
  
  'indexer-filters': 'Indexer filters selectively track specific events or transactions. This example demonstrates configuring filters to monitor only relevant contract activity. It shows how to optimize indexer performance by focusing on important data.',
  
  'indexer-aggregation': 'Indexer aggregation computes statistics from indexed data. This example demonstrates aggregating events, calculating metrics, and generating reports. It shows how to build analytics systems that process large amounts of blockchain data.',
  
  'indexer-performance': 'Indexer performance optimization improves query speed and efficiency. This example demonstrates techniques for optimizing indexer queries and data structures. It shows how to handle large datasets and maintain fast response times.',
  
  'indexer-monitoring': 'Indexer monitoring tracks indexer health and performance. This example demonstrates monitoring indexer status, detecting issues, and ensuring data consistency. It shows how to maintain reliable indexing infrastructure.',
}

// Default explanation for contracts without specific explanations
export const getContractExplanation = (exampleId) => {
  return contractExplanations[exampleId] || 
    `This ${exampleId.replace(/-/g, ' ')} contract demonstrates key NEAR smart contract concepts. Explore the code to understand how it implements ${exampleId.includes('nft') ? 'NFT' : exampleId.includes('cross') ? 'cross-contract' : 'smart contract'} functionality on the NEAR blockchain.`
}

